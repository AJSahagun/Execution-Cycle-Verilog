$date
	Thu May 02 16:47:25 2024
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module Fetch_tb $end
$var wire 32 ! pc_next [31:0] $end
$var wire 32 " pc_current [31:0] $end
$var wire 32 # instruction [31:0] $end
$var parameter 32 $ CLK_PERIOD $end
$var reg 1 % clk $end
$var reg 1 & reset $end
$var integer 32 ' i [31:0] $end
$scope module uut $end
$var wire 1 % clk $end
$var wire 32 ( pc_current [31:0] $end
$var wire 32 ) pc_next [31:0] $end
$var wire 1 & reset $end
$var wire 32 * pc_address [31:0] $end
$var wire 32 + new_pc [31:0] $end
$var wire 32 , instruction [31:0] $end
$scope module IM $end
$var wire 1 % clk $end
$var wire 32 - pc_address [31:0] $end
$var parameter 32 . MEM_SIZE $end
$var reg 32 / default_instruction [31:0] $end
$var reg 32 0 instruction [31:0] $end
$upscope $end
$scope module PC $end
$var wire 1 % clk $end
$var wire 1 & reset $end
$var wire 32 1 new_pc [31:0] $end
$var reg 32 2 pc_address [31:0] $end
$upscope $end
$scope module PCAdder $end
$var wire 32 3 pc_out [31:0] $end
$var reg 32 4 adder_out [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b10000000000 .
b1010 $
$end
#10000
$dumpvars
b100 4
b0 3
b0 2
b100 1
b100000000010000000000000100000 0
b11011110101011011011111011101111 /
b0 -
b100000000010000000000000100000 ,
b100 +
b0 *
b100 )
b0 (
b0 '
1&
0%
b100000000010000000000000100000 #
b0 "
b100 !
$end
#15000
1%
#20000
0%
b1 '
0&
#25000
b1000 !
b1000 )
b1000 +
b1000 1
b1000 4
b100 "
b100 (
b100 *
b100 -
b100 2
b100 3
1%
#30000
0%
b10 '
#35000
b1100 !
b1100 )
b1100 +
b1100 1
b1100 4
b10101100000100000000000000000100 #
b10101100000100000000000000000100 ,
b10101100000100000000000000000100 0
b1000 "
b1000 (
b1000 *
b1000 -
b1000 2
b1000 3
1%
#40000
0%
b11 '
#45000
b10000 !
b10000 )
b10000 +
b10000 1
b10000 4
b1100 "
b1100 (
b1100 *
b1100 -
b1100 2
b1100 3
b10010001100100000000000001001 #
b10010001100100000000000001001 ,
b10010001100100000000000001001 0
1%
#50000
0%
b100 '
