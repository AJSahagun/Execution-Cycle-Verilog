$date
	Sat May 04 20:08:59 2024
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module store_tb $end
$var wire 32 ! Write_data [31:0] $end
$var wire 1 " MemWrite $end
$var wire 32 # ALU_result [31:0] $end
$var reg 32 $ Read_data2 [31:0] $end
$var reg 1 % clk $end
$var reg 32 & instruction [31:0] $end
$var reg 1 ' reset $end
$scope module DUT $end
$var wire 32 ( Read_data1 [31:0] $end
$var wire 32 ) Read_data2 [31:0] $end
$var wire 1 % clk $end
$var wire 32 * instruction [31:0] $end
$var wire 1 ' reset $end
$var wire 32 + Sign_extended [31:0] $end
$var wire 1 , ALU_zero $end
$var wire 32 - ALU_output [31:0] $end
$var reg 32 . ALU_result [31:0] $end
$var reg 1 " MemWrite $end
$var reg 32 / Write_data [31:0] $end
$scope module SE $end
$var wire 16 0 in [15:0] $end
$var wire 32 1 out [31:0] $end
$upscope $end
$scope module alu_inst $end
$var wire 32 2 a [31:0] $end
$var wire 3 3 alu_control [2:0] $end
$var wire 32 4 b [31:0] $end
$var wire 1 , zero $end
$var reg 32 5 result [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#10
$dumpvars
bx 5
bx 4
b10 3
bz 2
bx 1
bx 0
bx /
bx .
bx -
x,
bx +
bx *
bx )
bz (
1'
bx &
0%
bx $
bx #
x"
bx !
$end
#15
1%
#20
b10010001101000101011001111000 !
b10010001101000101011001111000 /
1"
b100 +
b100 1
b100 4
b100 0
0%
b10010001101000101011001111000 $
b10010001101000101011001111000 )
b10101100100010010000000000000100 &
b10101100100010010000000000000100 *
#25
1%
#30
b10101011110011011110111100000001 !
b10101011110011011110111100000001 /
b100000 +
b100000 1
b100000 4
b100000 0
0%
b10101011110011011110111100000001 $
b10101011110011011110111100000001 )
b10101100100010100000000000100000 &
b10101100100010100000000000100000 *
#35
1%
#40
0%
#45
1%
#50
0%
